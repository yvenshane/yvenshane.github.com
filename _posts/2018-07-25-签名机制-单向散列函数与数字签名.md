---
title: iOS 签名机制 - 单向散列函数与数字签名
key: 20180724
tags:
---

## 单向散列函数 (One-way hash function)
**单项散列函数**：可以根据消息内容计算出散列值。
![单项散列函数图示](https://raw.githubusercontent.com/yvenshane/yvenshane.github.io/master/_posts/Images/2018-07-25/49DE39F9-46EE-4A55-A143-7492ED7A8052.png)

* 散列值的长度和消息的长度无关，单项散列函数会自己计算出固定长度的散列值。
* 消息哪怕只有1bit 的区别，也会产生完全不同的散列值。
* 具有单向性，消息只能通过单向散列函数得到散列值，散列值无法通过单向散列函数得到消息。
* 单项散列函数，又被称为消息摘要函数(message digest[daɪˈdʒest] function)，哈希函数。
* 输出的散列值，也被称为消息摘要(message digest)，指纹(fingerprint[ˈfɪŋgərprɪnt])。

### 常见的几种单项散列函数
**MD4、MD5**

* 产生128bit 的散列值。
* MD 就是 Message Digest 的缩写。
* Mac 终端自带 MD5 命令。

**SHA-1**

* 产生160bit 的散列值。

**SHA-2**

* SHA-256、SHA-384、SHA-512，散列值长度分别为256bit、384bit、512bit。

**SHA-3**

* 全新标准

### 如何防止数据被篡改

**场景一**

你整理了一份文件，整理完后电脑被 Malloary 攻击，如何确认你整理的这份文件未被篡改。

* 你在整理完文件后，使用单向散列函数生成一个散列值，并保存在安全的地方。
* 再次使用这份文件时，通过单向散列函数生成一个散列值，并与之前保存的散列值作比对，确认文件完整度。

**场景二**

公司将软件放在镜像站点，分散通信负荷，如何保证用户从镜像站点下载的软件未被篡改。

* 公司将软件通过单向散列函数生成一个散列值，并公示出来。
* 用户将从镜像站点下载的软件，使用单向散列函数生成一个散列值，并与公司官网所公示的散列值作比对，确认文件完整度。

**场景三**

 在注册账号时，我们将账号密码发送给服务器，服务器将账号密码存储在数据库，如果数据库被攻破，我们的账号密码将以明文的形式展现出来。
 
 * 我们在账号密码发送到服务器之前，将密码通过单向散列函数生成一个散列值，将密码的散列值发送给服务器。
 * 每次登录只需要比对账号下的密码的散列值，与数据库中注册时存储的散列值是否一致，即可判断密码是否正确。

 大多数网站都不提供找回密码的功能(既找回注册时输入的密码)，因为网站压根没有保存你的密码，保存的时候用你密码生成的散列值。
 
## 数字签名
**Alice 发送消息给 Bob**

* Alice 发送的内容有可能被篡改。
* 或者有人伪装成 Alice 发消息。
* 或者消息就是 Alice 发送的，但是她予以否认。

Bob 如何确认这段消息的真实性，如何识别篡改，伪装，否认？

**解决方案**：数字签名

**生成签名**：由消息的发送者完成，通过“签名密钥”生成。

**验证签名**：由消息的接受者完成，通过“验证密钥”验证。

用消息发送者的私钥进行数字签名，来保证这个签名是消息发送者的。

**回顾公钥密码**
![回顾公钥密码](https://raw.githubusercontent.com/yvenshane/yvenshane.github.io/master/_posts/Images/2018-07-25/3EEE72A5-0CC9-4F55-A724-1D150278B961.png)

**数字签名**
![数字签名图示](https://raw.githubusercontent.com/yvenshane/yvenshane.github.io/master/_posts/Images/2018-07-25/54811DCD-2EA7-4FEC-870B-E495F884C79B.png)

### 数字签名的过程

**Alice 发送消息给 Bob**

* Alice 用自己的私钥对消息进行签名
* Alice 将未签名的消息和签名后的消息一起发送给 Bob
* Bob 获取到签名后的消息，利用 Alice 的公钥来验证签名，并将验证后的消息与未签名的消息进行比对，得到验证结果。

**存在的问题**：发送的消息过多，过大(签名的消息，未签名的消息)

### 改进

**Alice 发送消息给 Bob**

* Alise 通过单向散列函数计算出消息的散列值
* Alice 用自己的私钥对散列值进行签名
* Alice 将未签名的消息和签名后的散列值一起发送给 Bob
* Bob 获取到未签名的消息后，对消息进行单向散列函数计算出未签名消息的散列值。
* Bob 将签名后的散列值，利用 Alice 的公钥验证签名，并与未签名的散列值进行比对，得到验证结果。

**图示**
![数字签名改进图示](https://raw.githubusercontent.com/yvenshane/yvenshane.github.io/master/_posts/Images/2018-07-25/84FC4F94-585F-4904-9B6E-F1AFC8F11372.png)

### 数字签名和公钥密码对比

|			|		  私钥	     |        公钥        |
|:------- |:---------------:| -----------------:|
| 公钥密码 |  接收者解密时使用  |   发送者加密时使用   |
| 数字签名 | 签名者生成签名使用  | 验证者验证签名时使用 |
| 持有密钥 |     个人持有      |  任何人都可以持有    |

* 数字签名与公钥密码反过来使用

### 其他疑虑

Q：如果有人篡改了文件内容或者签名内容会有什么结果?

A：签名验证失败，证明内容被篡改

Q：数字签名不能保证机密性?

A：数字签名的使用目的是为了识别内容有没有被篡改，无法保证机密性

* 确认消息完整性
* 识别消息是否被篡改
* 防止消息发送人否认所发送的内容

### 数字签名无法解决的问题
**中间人攻击**

**Alice 向 Bob 发送消息** 

* 为保证消息的机密性，Bob 生成密钥对，并将公钥发送给 Alice
* Mallory 窃取公钥
* Mallory 生成伪造的密钥对，并将伪造的公钥发送给 Alice 
* Alice 得到伪造的公钥
* Alice 用伪造的公钥给消息加密，并发送给Bob
* Mallory 截取到这条消息，并伪造一条新消息
* Mallory 利用 Bob 的公钥加密伪造的消息，并发送给 Bob
* Bob 用自己的私钥解密这条伪造的消息

数字签名有一步很重要的操作，就是利用公钥验证签名，而这个公钥很有可能被中间人所拦截

**数字签名的前提**

* 用于验证签名的公钥必须属于真正的发送者

**如果遭遇了中间人攻击**

* 公钥将是伪造的
* 数字签名将失效

验证签名之前必须的合法性!

**如何验证公钥的合法性**

* 证书 
